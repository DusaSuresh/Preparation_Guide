Kubernetes Overview and Details for Technical Architect Interview

1. Introduction to Kubernetes

What is Kubernetes?
Kubernetes (K8s) is an open-source platform designed to automate the deployment, scaling, and management of containerized applications. It provides a robust framework for managing containerized workloads and services with features such as automated deployment, scaling, and operations.

Example:
Imagine you have a microservices-based application running in multiple containers. Kubernetes can manage the lifecycle of these containers, including scaling them up or down based on demand, updating them with minimal downtime, and ensuring high availability.

Why Use Kubernetes?

Scalability: Automatically scale applications up or down based on demand.
High Availability: Ensure applications are resilient and available, even in case of failures.
Self-Healing: Automatically restart failed containers, reschedule them, and replace them as needed.
Service Discovery: Easily expose services to other services and external users.
Declarative Configuration: Use YAML files to define and manage application configurations.

2. Kubernetes Architecture

Kubernetes Components

Master Node: Manages the Kubernetes cluster. It runs the API server, controller manager, scheduler, and etcd.
API Server: Exposes the Kubernetes API for managing the cluster.
Controller Manager: Handles the routine tasks in the cluster.
Scheduler: Distributes workloads across the cluster based on resource availability.
etcd: Consistent and highly-available key-value store used for storing cluster state.
Worker Nodes: Run the application containers. Each node includes:
Kubelet: An agent that ensures containers are running in a Pod.
Kube-Proxy: Maintains network rules for Pod communication.
Container Runtime: Executes the containers (e.g., Docker, containerd).
Example:

yaml
Copy code
# Sample pod configuration
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: my-container
    image: nginx
    ports:
    - containerPort: 80
3. Core Concepts

Pods
------
The smallest deployable units in Kubernetes, representing a single instance of a running process in the cluster. Pods can host one or more containers.

Example:

yaml
Copy code
apiVersion: v1
kind: Pod
metadata:
  name: my-app
spec:
  containers:
  - name: my-app-container
    image: myapp:latest
    ports:
    - containerPort: 8080
	
	
Deployments
--------------
Manage the deployment and scaling of Pods. They provide declarative updates to Pods and ReplicaSets.

Example:

yaml
Copy code
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: myapp:latest
        ports:
        - containerPort: 8080

Services
---------
Abstract a set of Pods and provide a stable endpoint for accessing them. Services can be of types like ClusterIP (default), NodePort, LoadBalancer, and ExternalName.

Example:

yaml
Copy code
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: LoadBalancer

Ingress
----------
Manages external access to the services, typically HTTP. Ingress controllers manage routing rules.

Example:

yaml
Copy code
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: my-service
            port:
              number: 80


ConfigMaps and Secrets
----------------------
ConfigMaps: Store configuration data as key-value pairs.
Secrets: Store sensitive information like passwords and API keys.
Example ConfigMap:

yaml
Copy code
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config
data:
  APP_MODE: production
Example Secret:

yaml
Copy code
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  password: cGFzc3dvcmQ= # base64 encoded 'password'

4. Working with Kubernetes
-------------------------

Installation and Setup
Kubernetes can be installed using various methods:

Minikube: Local development environment.
Kubeadm: Tool for setting up Kubernetes clusters.
Managed Kubernetes Services: AWS EKS, Azure AKS, GCP GKE.
Example:

bash
Copy code
# Installing Minikube
minikube start

# Creating a cluster with kubeadm
kubeadm init

# Configuring kubectl to use the new cluster
kubectl config set-context --current --namespace=default
Kubectl Commands

kubectl get: List resources.
kubectl describe: Show detailed information about a resource.
kubectl apply: Apply configuration changes.
kubectl delete: Delete resources.
Example:

bash
Copy code
# Listing pods
kubectl get pods

# Applying a configuration
kubectl apply -f my-deployment.yaml

# Deleting a resource
kubectl delete pod my-pod
5. Kubernetes Networking

Cluster Networking
Kubernetes supports various network plugins like Calico, Flannel, and Weave to enable Pod-to-Pod communication across nodes.

Example:

bash
Copy code
# Installing Calico
kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml
Services and Load Balancing
Kubernetes Services provide load balancing by default, distributing traffic across Pods. For external load balancing, use LoadBalancer or Ingress.

Example:

bash
Copy code
# Exposing a service with a LoadBalancer
kubectl expose deployment my-deployment --type=LoadBalancer --name=my-service
DNS and Service Discovery
Kubernetes provides built-in DNS for services, allowing Pods to resolve service names to IP addresses.

Example:

bash
Copy code
# Resolving a service name from within a Pod
kubectl exec -it my-pod -- nslookup my-service
6. Kubernetes Storage

Persistent Volumes (PVs) and Persistent Volume Claims (PVCs)

PVs: Storage resources in the cluster.
PVCs: Requests for storage by users.
Example PV:

yaml
Copy code
apiVersion: v1
kind: PersistentVolume
metadata:
  name: my-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /mnt/data
Example PVC:

yaml
Copy code
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
Storage Classes
Define different types of storage, such as SSD or HDD, and provide dynamic provisioning of PVs.

Example:

yaml
Copy code
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-storage
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
7. Kubernetes Deployments

Rolling Updates and Rollbacks
------------------------------
Kubernetes supports rolling updates to deploy changes without downtime and rollbacks to revert to previous versions.

Example:

bash
Copy code
# Updating a deployment
kubectl set image deployment/my-deployment my-container=myapp:latest

# Rolling back to a previous version
kubectl rollout undo deployment/my-deployment

Canary Deployments
-------------------
Gradually roll out new versions of an application to a subset of users before a full rollout.

Example:

yaml
Copy code
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-canary-deployment
spec:
  replicas: 5
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: myapp:canary
        ports:
        - containerPort: 8080
		
Blue/Green Deployments
----------------------
Deploy a new version alongside the old version and switch traffic to the new version once it is verified.

Example:

yaml
Copy code
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-blue-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: myapp:blue
        ports:
        - containerPort: 8080
8. Kubernetes Security

RBAC (Role-Based Access Control)
Control access to Kubernetes resources based on roles and permissions.

Example:

yaml
Copy code
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: my-role
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
Network Policies
Define rules to control traffic between Pods.

Example:

yaml
Copy code
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-apps
spec:
  podSelector:
    matchLabels:
      app: my-app
  ingress:
  - from:
    - podSelector:
        matchLabels:
          role: frontend
Secrets Management
Use Kubernetes Secrets to store and manage sensitive data securely.

Example:

yaml
Copy code
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  password: cGFzc3dvcmQ= # base64 encoded 'password'
9. Kubernetes in Production

Monitoring and Logging
Integrate with monitoring and logging tools like Prometheus, Grafana, and ELK Stack for observability.

Example:

yaml
Copy code
# Prometheus deployment example
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - name: prometheus
        image: prom/prometheus
        ports:
        - containerPort: 9090
Scaling Applications
Use Horizontal Pod Autoscalers (HPA) to automatically scale Pods based on resource utilization.

Example:

yaml
Copy code
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: my-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-deployment
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 50
Backup and Recovery
Implement backup solutions for etcd and application data. Regularly back up critical resources and configurations.

Example:

bash
Copy code
# Backing up etcd
ETCDCTL_API=3 etcdctl snapshot save /backup/etcd-snapshot.db
10. Kubernetes in Cloud

Managed Kubernetes Services
Use services like AWS EKS, Azure AKS, and Google GKE for managing Kubernetes clusters in the cloud.

Example with AWS EKS:

bash
Copy code
# Creating an EKS cluster
aws eks create-cluster --name my-cluster --role-arn <role-arn> --resources-vpc-config subnetIds=<subnet-ids>,securityGroupIds=<security-group-ids>

# Updating kubeconfig
aws eks update-kubeconfig --name my-cluster
Hybrid Deployments
Combine on-premises and cloud resources, using Kubernetes to manage both environments.

Example:

yaml
Copy code
apiVersion: cluster.x-k8s.io/v1alpha1
kind: Cluster
metadata:
  name: hybrid-cluster
spec:
  controlPlaneEndpoint:
    host: hybrid.example.com
    port: 6443
Container Registries
Store and manage container images in registries such as Docker Hub, AWS ECR, Azure ACR, and Google Container Registry.

Example with AWS ECR:

bash
Copy code
# Creating a repository
aws ecr create-repository --repository-name my-repo

# Pushing an image
aws ecr get-login-password --region <region> | docker login --username AWS --password-stdin <account-id>.dkr.ecr.<region>.amazonaws.com
docker tag myapp:latest <account-id>.dkr.ecr.<region>.amazonaws.com/my-repo:latest
docker push <account-id>.dkr.ecr.<region>.amazonaws.com/my-repo:latest
11. Hands-On Practice

Real-World Scenarios
Design Kubernetes-based architectures for various applications. Consider aspects like scaling, fault tolerance, and deployment strategies.

Troubleshooting Common Issues

Networking Issues: Check network policies and service configurations.
Storage Issues: Verify PV and PVC configurations.
Performance Issues: Monitor resource usage and optimize Pod configurations.
Kubernetes Best Practices

Use Helm charts for templating Kubernetes configurations.
Implement resource limits and requests for Pods.
Regularly update and patch Kubernetes components and applications.
12. Preparing for the Interview

Mock Scenarios
Design Kubernetes architectures for sample applications, focusing on aspects such as scaling, high availability, and deployment strategies.

Example Scenario:
Design a scalable microservices application with Kubernetes. Include services for web, API, and database components. Use Kubernetes features like Deployments, Services, and Ingress for managing the application.

Common Interview Questions

Explain the difference between a Pod and a Deployment.
How does Kubernetes handle service discovery?
Describe how you would implement a rolling update in Kubernetes.