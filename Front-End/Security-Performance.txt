Security:
==========

-> XSS - React itself take care using escape but dangerouslySetHtml in this case input has to be sanitized. Sanitization done using DOMPurify library.

-> CSP - Consent Security Policies . Normally will load js, css, frames, images etc. Here if we add few polices like allow those domains only it will allow.

-> Authentication —> Authentication data should not be handled at client side. If you use cookies for token then only use HttpOnly. This one will not be accessible from JS.

-> CSRF -> This one will be handled at server side, if we keep this server will check for specific domains.

-> CORS -> Any external calls will be stopped by placing cars at server side. It will allow only specific domain calls by using Access-control-allow-origin

-> Input sanitization —>Always sanitize the input received from the forms or urls before using it.

-> Https - Always use https in network layer calls. This one will provide security at network by mTLS.

-> RateLimit - use debounce, throttling for making an api calls by stopping always making server side calls

-> Error handling -> Proper error handling has to be implemented.

-> Logging & Observability -> don’t add any sensitive data into logs. 

-> UI must not load in iframe -> X-FRAME-OPTIONS: DENY

Performance
=============

Core Web Vitals Assessment
---------------------------
- Most of the page performance is dependent on images size, Images size should be less than 20kb. If we make it, them most of the cases will resolve.
- While loading the images using link tag, we can keep "preload" flag, it will load without waiting for other scripts to load.
- Few external scripts will also take time to load, those needs to loaded properly to improve it.

LCP -> Largest Contentful Paint
FCP -> First Contentful Paint
CLS -> Cumulative Layout Shift - For example if in three rows images are getting loaded and in one row images loading little bit late. When it loaded automatically layout will shift.

-> We can check this performance metrics in "lighthouse" in iinspect element.
-> Performance of the site can also be checked in below sites.
  https://pagespeed.web.dev/
  https://gtmetrix.com/

> Avoid Unnecessary Re-renders -> React.memo(() => {}) -> React memo stop child re-renders when props didn’t change.

-> Memoize Calculations -> useMemo(()=> {},[value]) -> Heavy calculation will not be done on every re-render only when dependency changes.

-> Stabilize Function References -> Functions are recreated on every render → causes child re-renders. useCallback(() => {})

-> Code-Splitting & Lazy Loading -> using React lazy load, we can split component into chunk and loaded on demand.

Const Profile = React.lazy(() => import(‘./Profile’));
<Suspense fallback={<div>…loading</div>}><Profile></Suspense>

->Virtualization for Large Lists -> For long list display in component we can use below libraries so that entire list will not be loaded initially instead of viewPort size only loaded
	- react window
	- react virtualized

-> Avoid Deep Object/Array State Mutations -> if you mutate state directly, re-render won’t done properly. So state should be compared with previous one and update it

-> useThrottling, debounce -> use this for heavy operations.

-> Preload, Prefetch & Preconnect
	Preload (load critical resources early) —> <link rel="preload" href="/big-font.woff2" as="font">
	Prefetch (load future page resources) —> <link rel="prefetch" href="/dashboard.js">
	Preconnect (DNS/TLS warmup) —> <link rel="preconnect" href="https://api.example.com">

-> Image Optimization Techniques
* Use webp/avif
* Lazy load images
* Use CDN
* Compress images

-> Avoid indexes as keys in list

